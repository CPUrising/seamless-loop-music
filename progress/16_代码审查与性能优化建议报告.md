# 代码审查与性能优化建议报告

**日期**: 2026-02-11  
**审查人**: 莱芙 (Lev Zenith)  
**审查对象**: 核心架构 (PlayerService + AudioLooper + DatabaseHelper)

---

## 1. 🚨 关键风险 (Critical Risks)

### 1.1 线程安全与竞态条件 (AudioLooper.cs)
**风险等级**: **高 (崩溃风险)**
**位置**: `AudioLooper.cs` -> `TotalTime` / `CurrentTime`

**现象描述**:
UI 线程通过 `DispatcherTimer` 每 100ms 访问一次 `PlayerService.TotalTime`。而在某些场景下（如自动切歌、手动停止），后台线程可能会调用 `DisposeAudioResources` 释放 `_audioStream`。

**根本原因**:
```csharp
// UI 线程调用
public TimeSpan TotalTime => _audioStream.TotalTime; 

// 后台线程调用
private void DisposeAudioResources() {
    _audioStream?.Dispose(); // 销毁对象
    _audioStream = null;     // 置空引用
}
```
如果 `Dispose` 刚执行完（或正在执行），UI 线程访问 `_audioStream.TotalTime` 就会抛出 `NullReferenceException` 或 `ObjectDisposedException`，导致程序闪退。

**修复建议**:
- 在访问器中增加空值检查 (`?.`)。
- 使用 `lock` 锁机制或 `Interlocked` 确保资源访问的原子性。
- 在 `Dispose` 期间，返回 `TimeSpan.Zero` 而不是让程序崩溃。

### 1.2 数据库死锁风险 (DatabaseHelper.cs)
**风险等级**: **中 (操作失败)**
**位置**: `DatabaseHelper.cs` (SQLite Default Journal Mode)

**现象描述**:
当后台正在进行“文件夹导入”这种重度写入操作时，如果用户在 UI 上尝试“修改别名”或“保存循环点”，可能会遇到 `database is locked` 错误。

**根本原因**:
SQLite 默认的 `DELETE` 日志模式在写入时会锁住整个数据库文件，阻止其他读取或写入操作。

**修复建议**:
由于我们的应用涉及后台扫描（写）+ 前台播放（读/写），**强烈建议开启 WAL (Write-Ahead Logging) 模式**。
在 `InitializeDatabase` 中执行：
```sql
PRAGMA journal_mode = WAL;
```
这将允许读写并发执行，大幅提升响应速度。

---

## 2. ⚡ 性能优化 (Performance Optimization)

### 2.1 批量导入性能瓶颈
**影响**: **严重 (导入慢)**
**位置**: `PlayerService.cs` -> `ScanAndAddFolderToPlaylist`

**问题分析**:
在循环中处理成百上千个文件时：
```csharp
foreach (var f in files) {
    // 每次都 new SQLiteConnection -> Open -> Transaction -> Commit -> Close
    _dbHelper.SaveTrack(track); 
    _dbHelper.AddSongToPlaylist(...);
}
```
这意味着导入 1000 首歌会触发 2000+ 次数据库连接和事务提交，极其低效，不仅慢，还伤硬盘。

**优化方案**:
- 在 `DatabaseHelper` 中封装一个 `RunInTransaction(Action<IDbConnection> action)` 方法。
- 或者直接在 Service 层将整个循环包裹在一个大事务中。
- **预期收益**: 导入速度可提升 **10-100 倍**。

### 2.2 重复的文件 IO 操作
**影响**: **轻微 (CPU/IO 浪费)**
**位置**: `ScanAndAddFolderToPlaylist`

**问题**:
每次导入时都会重新计算 `GetTotalSamples`（需要读取整个文件头，甚至解码）。虽然对于新文件必须这么做，但对于数据库里**已经存在且未修改**的文件，这完全是多余的。

**优化方案**:
- 先通过 文件名+大小 快速查询数据库。
- 如果数据库已有记录，直接复用其 `TotalSamples`，跳过繁重的音频文件读取步骤。

---

## 3. 🛡️ 代码健壮性建议

### 3.1 异常捕获边界
目前 `MainWindow.xaml.cs` 中的部分 UI 事件处理逻辑缺乏 `try-catch` 包裹。如果 `Services` 层抛出未预料的异常（如文件被占用、权限不足），UI 层可能会直接崩溃。建议在所有 `async void` 事件处理程序顶层增加捕获逻辑。

### 3.2 资源释放规范
`PlayerService` 虽然实现了 `IDisposable`，但在 `MainWindow` 关闭时 (`OnClosing`) 并没有显式调用它。
建议在 `MainWindow.xaml.cs` 中重写 `OnClosed`：
```csharp
protected override void OnClosed(EventArgs e) {
    _playerService?.Dispose();
    base.OnClosed(e);
}
```
确保音频设备被正确释放，避免进程残留。

---

## 4. 📝 总结
总体代码结构清晰，MVVM 分层合理。
优先解决 **AudioLooper 的线程安全问题** 和 **DatabaseHelper 的 WAL 模式**，即可显著提升稳定性。后续如果遇到性能瓶颈，再着手优化批量导入逻辑。

此报告供后续迭代参考。
