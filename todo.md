由于项目全为AI生成，只会C++，不会C#，目前正在潜心修炼，看懂自己的代码。。。

可以改歌曲名字，

MP3，WAV格式的实验

繁体中文版？

日文版?

也要增加根据前面的指纹找后面的的位置方法，尤其是循环开始点不足一秒的时候，而且friend to lover也不好找。不过像这样比较完整的歌曲，末尾并不是循环的重复消音，似乎也可以保留？

允许在软件里修改歌曲名

更换播放设备时停止播放？（如拔耳机）

再开发一个傅里叶变化的寻找最佳循环点的，以便批量处理？
通常业界会用 **FFT (快速傅里叶变换)** 来做互相关运算（Cross-Correlation），或者用 **金字塔搜索**（先由粗到细）。
以后要做“整首歌的音频指纹识别”（比如听歌识曲），金字塔搜索就是必备神技
按照 **时间复杂度 (效率从高到低)** 排序如下：

###### 1. ⚡ **过零点检测 (Zero-Crossing)**

- **复杂度**: $O(N)$
- **解释**: 只需要把数据从头到尾扫一遍，看到 0 就停。线性复杂度，最快。
- **特性**: 有手就行，但精度低，只能防爆音，不能对波形。

###### 2. 🔼 **金字塔搜索 (Pyramid Search)**

- **复杂度**: $O(N)$ (近似)
- 解释

  :

  - 构建金字塔（每层降采样）总共需要处理约 $N + N/2 + N/4 + ... = 2N$ 个点。
  - 搜索过程在每一层只搜极小范围，几乎可以忽略不计。
  - 所以总体开销主要在“缩图”上，是线性的。
- **特性**: 极快，适合大范围模糊搜索。

###### 3. 🌊 **FFT 互相关 (Fast Fourier Transform)**

- **复杂度**: $O(N \log N)$
- 解释

  :

  - FFT 的魔力在于把乘法变成了加法（对数级）。
  - 当 M (模板) 很大时（比如 44100 个点），$\log N$ (约等于16) 远小于 M。
  - 所以在**长片段匹配**时，它是当之无愧的王者。

###### 4. 🐢 **暴力匹配 (Naive SAD) —— [当前代码]**

- **复杂度**: $O(N \times M)$
- 解释

  :

  - 外层循环跑 N-M 次，内层循环跑M次。
  - 这是一个**二次方 (Quadratic)** 级别的复杂度。
- 现状分析

  :

  - 我们现在的

    $$
    M (1秒) \approx 44,100
    $$

    。
  - 我们现在的

    $$
    N (4秒) \approx 176,400
    $$

    。
  - **运算量**: 约

    $$
    1.8 \times 10^5 \times 4.4 \times 10^4 \approx 79 亿次
    $$

    运算。
  - 现在的优化

    : 我们用了

    ```
    step += 4
    ```

    ，这把运算量除以了 4，但依然是亿级别的。
  - **为什么还能跑?**: 现代 CPU 每秒能跑几十亿次，加上 C# 数组访问很快，所以勉强能在几百毫秒内算出结果。但如果是 10秒 以上的搜索，这个算法就会让界面卡死了。

修改时间UI，加一个单位s,或添加文字告知

去你妈的friend to lover，为什么网易云里每首歌都有完美的结尾

增加对白色相簿AB式循环的方案

增加all play模式,每首歌之间加上歌曲循环开头三秒，有淡入淡出的衔接

按下下一首时，列表随之移动

我的歌单添加时，允许直接输入地址进行跳转

判断是否循环——首先排除人声

偶发崩溃？忽然卡住（包括整个电脑）滋滋滋，随后恢复正常？别人怎么做的？

理论上那里的歌我也可以无缝循环播放，但是对于不熟悉这个音乐的人来说，循环点不是很好找

倒不如搭建网站收录音乐的起始点。。。算了不多，塞到github也行吧
根据游戏标题筛选歌曲列表？
建立网站，供人提交，设置API，进行校对

[MP3循环器 - 带有视觉波形编辑器的免费在线音频循环工具](https://miniwebtool.com/zh-cn/mp3-循环器/)也可以参考这个？

[7款适用于桌面和网页的 Incredible Loop 音频工具](https://www.avaide.com/zh/edit-audio/loop-audio/)姑且研究研究

跳转音乐时有爆烈声，有时智能匹配时也存在

以及经常挂掉

禁止双开（为了显得更专业），可以在

```
App.xaml.cs
```

 里通过

```
Mutex
```

 (互斥体) 来实现单例检测。

默认打开之前所在文件夹

关于软件的开发，我觉得应该适可而止。关于这个软件的定位，应当始终为少数游戏爱好者服务而已。

还是把所有的配置文件放到同一个configue文件夹吧

音量调整键怎么可以移动到外侧了？？？

再添加一个随机播放，歌单支持添加多个文件夹，模仿MyuneMusic

重命名界面太TM丑了，借用VB的玩意儿。。。

###### 2. UI 刷新技巧 (L186-L189)

```
lstPlaylists.ItemsSource = null;

lstPlaylists.ItemsSource = _playlists;
```

- 这是什么操作？

  - 这是一种简单粗暴但有效的**强制刷新法**。
  - WPF 的列表绑定有时比较“懒”，如果您直接往

    ```
    List
    ```

    里加东西，它可能装作没看见。
  - 先设为

    ```
    null
    ```

    (断开连接)，再设回去 (重新连接)，就能逼迫它重新渲染整个列表。虽然不是性能最高的做法（最好是用

    ```
    ObservableCollection
    ```

    ），但在这种只有几十个歌单的小规模数据下，它是最省心的。
    但老子不能忍受！我要是把兰斯所有的歌都塞里面怎么办！

**TextBlock / Label (文本块/标签）**它可以被设置为

```
IsTextSelectionEnabled="True"
```

 从而允许复制文字，

###### 本地化的方法

现在的写法（用

```
if/else
```

 或者三元运算符硬编码在 C# 代码里）是典型的 **“硬编码 (Hard-coding)”** 坏味道。

**为什么它糟糕？**

1. 维护地狱

   ：如果有 5 门语言，每个文本处都要写

   ```
   if(lang=="cn")... else if(lang=="jp")... else if(lang=="fr")...
   ```

   ，代码会乱成一锅粥。
2. **非路人友好**：如果您想请一个不懂编程的翻译来帮忙翻阿拉伯语，他根本没法下手，因为文字都藏在代码里。

**专业的解决方案 (Industry Standard)**： 应该使用 **资源文件 (Resource Files, .resx)** 或者 **JSON/XML 字典**。

如果是 WPF 项目，最正统的做法是：

1. 创建

   ```
   Strings.zh-CN.resx
   ```

   ,

   ```
   Strings.en-US.resx
   ```

   ,

   ```
   Strings.ja-JP.resx
   ```

   。
2. 在 XAML 里直接绑定：

   ```
   <TextBlock Text="{x:Static p:Resources.MyTitle}" />
   ```

   。
3. 切换语言时，只需要改变线程的

   ```
   CurrentUICulture
   ```

   ，WPF 会自动帮您刷新所有界面！

**或者更现代一点的做法 (JSON)**： 加载一个

```
lang_cn.json
```

：

```
json
{

  "btn_play": "播放",

  "title": "无缝循环"

}
```

代码里只写：

```
Display("btn_play")
```

虽然咱们现在的项目只有三十个左右的文本，目前的土办法还能凑合。但我不能忍受，要是有大佬帮我帮不了怎么办

###### **循环点记忆**CSV保存的改进方案

如果有几千首（甚至上万首）的规模，现有的

```
CSV + File.WriteAllLines
```

 方案确实会开始变慢，而且有隐患。

**现有方案的瓶颈**：

1. **全量重写**：每次保存（哪怕只改了一首歌），都要把几千行数据拼成字符串，把整个 CSV 文件从头到尾重写一遍。这在文件变大后会越来越慢（IO 压力）。
2. **启动加载慢**：启动时一次性把几千行读进内存解析，虽然现在电脑快，但也是不必要的开销。

**升级方案 (建议)**：

如果是几千首这个量级，**SQLite** 是最完美的接班人！

1. **为什么选 SQLite？**

   - 单文件

     ：它就像一个

     ```
     .db
     ```

     文件，和 CSV 一样方便携带。
   - **增量读写**：改一首歌的配置，只改那一行数据，毫秒级完成，不用重写整个文件。
   - **查询飞快**：几万条数据里找一首歌，对它来说是纳秒级的事并支持索引。
2. **或者...折中方案 (如果不想引入 SQLite 库)**

   - JSON

     ：换成 JSON 格式。虽然还是全量读写，但 C# 的

     ```
     Newtonsoft.Json
     ```

     或

     ```
     System.Text.Json
     ```

     序列化速度比我们手写的字符串拼接快得多，而且更健壮。
   - 分片

     ：如果歌真的超级多，可以按字母分文件存（如

     ```
     config_A.csv
     ```

     ,

     ```
     config_B.csv
     ```

     ），但逻辑会变复杂。

**莱芙的建议**： 如果是几千首，现在的 CSV 其实**还能撑得住**（现代 SSD 写个几百 KB 的文本也是瞬间的事）。 但如果到了几万首，或者您对性能有极致要求，莱芙建议我们在下一个版本中引入 **SQLite**！( •̀ ω •́ )✧

下一次，我得整理好我的release... 这次太乱了

configue保存音量设置

时不时被打断？线程不稳定？

右键或在某个界面可以打开歌曲文件夹

增加播放是否循环选项，是否可以循环的标签，来决定play all是否要从循环末尾处离开还是继续后面的播放

干脆做成可以利用pymusic的应用，算法靠他，只是调用，读取输出文件，但保留原来的匹配方法供（手机端）临时调整，要小心程序崩溃问题。问题来到如何存储循环信息。

###### 核心效果

可以无缝循环，播放所有的歌

好像修改循环点秒数，过大会炸

要是歌单里的歌文件不在了，播放这个歌会炸吗

优化添加歌曲界面：单曲添加与文件夹添加

一些内容的汉化，

pymusiclooper十个点的使用

干脆批量给每一首歌取得排行榜并保存吧

其实播放时不一定很稳定，会不会是解码导致的问题？

全自动按钮删除
查看排行榜：没有排行榜时，就运行匹配，取得保存排行榜，然后原来排行榜界面同之前。再增加按钮“更新排行榜”，取得保存排行榜
