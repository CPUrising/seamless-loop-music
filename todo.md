由于项目全为AI生成，只会C++，不会C#，目前正在潜心修炼，看懂自己的代码。。。

可以改歌曲名字，

MP3，WAV格式的实验

繁体中文的README

日文的README?

也要增加根据前面的指纹找后面的的位置方法，尤其是循环开始点不足一秒的时候，而且friend to lover也不好找

允许在软件里修改歌曲名

更换播放设备时停止播放？（如拔耳机）

再开发一个傅里叶变化的寻找最佳循环点的，批量处理工具
通常业界会用 **FFT (快速傅里叶变换)** 来做互相关运算（Cross-Correlation），或者用 **金字塔搜索**（先由粗到细）。
以后要做“整首歌的音频指纹识别”（比如听歌识曲），金字塔搜索就是必备神技
按照 **时间复杂度 (效率从高到低)** 排序如下：

###### 1. ⚡ **过零点检测 (Zero-Crossing)**

- **复杂度**: $O(N)$
- **解释**: 只需要把数据从头到尾扫一遍，看到 0 就停。线性复杂度，最快。
- **特性**: 有手就行，但精度低，只能防爆音，不能对波形。

###### 2. 🔼 **金字塔搜索 (Pyramid Search)**

- **复杂度**: $O(N)$ (近似)

- 解释

  :

  - 构建金字塔（每层降采样）总共需要处理约 $N + N/2 + N/4 + ... = 2N$ 个点。
  - 搜索过程在每一层只搜极小范围，几乎可以忽略不计。
  - 所以总体开销主要在“缩图”上，是线性的。

- **特性**: 极快，适合大范围模糊搜索。

###### 3. 🌊 **FFT 互相关 (Fast Fourier Transform)**

- **复杂度**: $O(N \log N)$

- 解释

  :

  - FFT 的魔力在于把乘法变成了加法（对数级）。
  - 当 M (模板) 很大时（比如 44100 个点），$\log N$ (约等于16) 远小于 M。
  - 所以在**长片段匹配**时，它是当之无愧的王者。

###### 4. 🐢 **暴力匹配 (Naive SAD) —— [当前代码]**

- **复杂度**: $O(N \times M)$

- 解释

  :

  - 外层循环跑 $N-M$ 次，内层循环跑 $M$ 次。
  - 这是一个**二次方 (Quadratic)** 级别的复杂度。

- 现状分析

  :

  - 我们现在的 M (1秒) $\approx$ 44,100。

  - 我们现在的 N (4秒) $\approx$ 176,400。

  - **运算量**: 约 $1.3 \times 10^5 \times 4.4 \times 10^4 \approx 57$ 亿次运算。

  - 现在的优化

    : 我们用了

     

    ```
    step += 4
    ```

    ，这把运算量除以了 4，但依然是亿级别的。

  - **为什么还能跑?**: 现代 CPU 每秒能跑几十亿次，加上 C# 数组访问很快，所以勉强能在几百毫秒内算出结果。但如果是 10秒 以上的搜索，这个算法就会让界面卡死了。

修改时间UI，加一个单位s,或添加文字告知

去你妈的friend to lover，为什么网易云里每首歌都有完美的结尾

增加对白色相簿AB式循环的方案

增加all play模式

按下下一首时，列表随之移动

我的歌单添加时，允许直接输入地址进行跳转

判断是否循环——首先排除人声

理论上那里的歌我也可以无缝循环播放，但是对于不熟悉这个音乐的人来说，循环点不是很好找

倒不如搭建网站收录音乐的起始点。。。算了不多，塞到github也行吧
根据游戏标题筛选歌曲列表？
建立网站，供人提交，设置API，进行校对

[MP3循环器 - 带有视觉波形编辑器的免费在线音频循环工具](https://miniwebtool.com/zh-cn/mp3-循环器/)也可以参考这个？

[7款适用于桌面和网页的 Incredible Loop 音频工具](https://www.avaide.com/zh/edit-audio/loop-audio/)姑且研究研究

跳转音乐时有爆烈声，有时智能匹配时也存在

以及经常挂掉



禁止双开（为了显得更专业），可以在 

```
App.xaml.cs
```

 里通过 

```
Mutex
```

 (互斥体) 来实现单例检测。
